var {
  _optionalChain
} = require('@sentry/utils');

Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const node = require('@sentry/node');
const utils$1 = require('@sentry/utils');
const debugBuild = require('../debug-build.js');
const utils = require('../utils.js');

/**
 * Wraps an event function handler adding it error capture and tracing capabilities.
 *
 * @param fn Event handler
 * @param options Options
 * @returns Event handler
 */
function wrapEventFunction(
  fn,
  wrapOptions = {},
) {
  return utils.proxyFunction(fn, f => utils.domainify(_wrapEventFunction(f, wrapOptions)));
}

/** */
function _wrapEventFunction(
  fn,
  wrapOptions = {},
) {
  const options = {
    flushTimeout: 2000,
    ...wrapOptions,
  };
  return (...eventFunctionArguments) => {
    const [data, context, callback] = eventFunctionArguments;

    return node.startSpanManual(
      {
        name: context.eventType,
        op: 'function.gcp.event',
        attributes: {
          [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'component',
          [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.serverless.gcp_event',
        },
      },
      span => {
        const scope = node.getCurrentScope();
        scope.setContext('gcp.function.context', { ...context });

        const newCallback = utils.domainify((...args) => {
          if (args[0] !== null && args[0] !== undefined) {
            node.captureException(args[0], scope => utils.markEventUnhandled(scope));
          }
          _optionalChain([span, 'optionalAccess', _ => _.end, 'call', _2 => _2()]);

          // eslint-disable-next-line @typescript-eslint/no-floating-promises
          node.flush(options.flushTimeout)
            .then(null, e => {
              debugBuild.DEBUG_BUILD && utils$1.logger.error(e);
            })
            .then(() => {
              if (typeof callback === 'function') {
                callback(...args);
              }
            });
        });

        if (fn.length > 2) {
          return core.handleCallbackErrors(
            () => (fn )(data, context, newCallback),
            err => {
              node.captureException(err, scope => utils.markEventUnhandled(scope));
            },
          );
        }

        return Promise.resolve()
          .then(() => (fn )(data, context))
          .then(
            result => newCallback(null, result),
            err => newCallback(err, undefined),
          );
      },
    );
  };
}

exports.wrapEventFunction = wrapEventFunction;
//# sourceMappingURL=events.js.map
