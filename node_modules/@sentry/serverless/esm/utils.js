import { runWithAsyncContext } from '@sentry/core';
import { addExceptionMechanism } from '@sentry/utils';

/**
 * @param fn function to run
 * @returns function which runs in the newly created domain or in the existing one
 */
function domainify(fn) {
  return (...args) => runWithAsyncContext(() => fn(...args), { reuseExisting: true });
}

/**
 * @param source function to be wrapped
 * @param wrap wrapping function that takes source and returns a wrapper
 * @param overrides properties to override in the source
 * @returns wrapped function
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function proxyFunction(
  source,
  wrap,
  overrides,
) {
  const wrapper = wrap(source);
  const handler = {
    apply: (_target, thisArg, args) => {
      return wrapper.apply(thisArg, args);
    },
  };

  if (overrides) {
    handler.get = (target, prop) => {
      if (Object.prototype.hasOwnProperty.call(overrides, prop)) {
        return overrides[prop ];
      }
      return (target )[prop ];
    };
  }

  return new Proxy(source, handler);
}

/**
 * Marks an event as unhandled by adding a span processor to the passed scope.
 */
function markEventUnhandled(scope) {
  scope.addEventProcessor(event => {
    addExceptionMechanism(event, { handled: false });
    return event;
  });

  return scope;
}

export { domainify, markEventUnhandled, proxyFunction };
//# sourceMappingURL=utils.js.map
